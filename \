<?php

	namespace apf\core{

		use \apf\core\config\attribute\Container	as	AttributeContainer;
		use \apf\core\config\Attribute;
		use \apf\core\config\Adapter;

		abstract class Config implements \Iterator{

			private	$attributeContainer	=	NULL;

			private	$isValidatedSoft		=	FALSE;
			private	$isValidatedHard		=	FALSE;
			private	$isValidatedExtra		=	FALSE;

			final public function __construct($parentObject,Config $config=NULL){

				$this->attributeContainer	=	new AttributeContainer();

				$this->attributeContainer->add(
															Array(
																	'name'			=>	'configurableObject',
																	'description'	=>	'The configurable object for which this configuration is meant.',
																	'value'			=>	$parentObject,
																	'exportable'	=>	FALSE,
																	'traversable'	=>	FALSE,
																	'readOnly'		=>	TRUE,
																	'validate'		=>	FALSE
															)
				);

				$this->configureAttributes();

				if($config !== NULL){

					$this->merge($config);

				}

			}

			public function validateConfigurableObject($object){
					
				$parentObjectClass	=	strtolower(get_class($object));
				$configClass			=	strtolower(get_class($this));

				$configClass			=	substr($configClass,0,strrpos($configClass,'\\'));

				if($configClass !== $parentObjectClass){
			
					throw new \InvalidArgumentException("Invalid parent object, expected $configClass, got $parentObjectClass instead");
	
				}

				return $object;

			}

			public function validate($mode=NULL,$reValidate=FALSE){

				$mode		=	strtolower(trim($mode));

				$modes	=	Array(
										'soft',
										'hard',
										'extra',
										'none'
				);

				if(!in_array($mode,$modes)){

					throw new \InvalidArgumentException("Invalid validation mode specified: \"$validateMode\"");

				}

				if($validateMode=='none'){

					return;

				}

				$class	=	self::getValidatorClass();

				if(!class_exists($class)){

					throw new \LogicException("No validator class found for this configurable object");

				}

				switch($mode){

					case 'soft':

							if($this->isValidatedSoft){

								return TRUE;

							}

							return $this->isValidatedSoft		=	$class::softConfigValidation($this->getConfig());

					break;

					case 'hard':

						if($this->isValidatedHard && !$reValidate){

							return TRUE;

						}

						return $this->isValidatedHard		=	$class::hardConfigValidation($this->getConfig());
					break;

					case 'extra':

						if($this->isValidatedExtra && !$reValidate){

							return TRUE;

						}

						return $this->isValidatedExtra	=	$class::extraConfigValidation($this->getConfig());

					break;

					default:
						throw new \InvalidArgumentException("Unknown validation method");
					break;

				}

			}

			//The is validated method is a shortcut to check if the object has been validated in any way, soft or hard
			public function isValidated(){

				return $this->isValidatedSoft || $this->isValidatedHard || $this->isValidatedExtra;

			}

			//The isValidatedSoft method will tell you if the configurable object has been validated soft.
			public function isValidatedSoft(){

				return $this->isValidatedSoft;

			}

			//The isValidatedHard method will tell you if the configurable object has been validated the hard way.
			public function isValidatedHard(){

				return $this->isValidatedHard;

			}

			//The isValidatedHard method will tell you if the configurable object has passed extra validations
			public function isValidatedExtra(){

				return $this->isValidatedExtra;

			}

			public function getConfigurableObject(){

				return $this->attributeContainer->get('configurableObject')->getValue();

			}

			private function makeValidatorName($name){

				return sprintf('validate%s',ucwords($name));

			}

			public function hasValidator($name){

				return method_exists($this,$this->makeValidatorName($name));

			}

			public function getValidator($name){

				if(!$this->hasValidator($name)){

					throw new \InvalidArgumentException("No validator found for attribute $name");		

				}

				return $this->makeValidatorName($name);

			}

			public function validateAttribute($name,$value){

				$validator	=	$this->getValidator($name);
				return $this->$validator($value);

			}

			protected function addAttribute(Array $parameters){

				$parameters['config']	=	$this;

				$this->attributeContainer->add(new Attribute($parameters));

				return $this;

			}

			/**
			 * Returns setters and getters according to the attributes set on the configuration
			 * This is provided due to hidden functionality in the __call magic method.
			 * When exploring a new framework, I particularly tend to var_dump(get_class_methods($class))
			 * I find it frustrating when certain functionality is not obvious.
			 * This method is provided to leverage said frustration.
			 */

			public function getMethods(){

				$methods	=	Array();

				foreach($this->attributeContainer as $attribute){

					$methods[]	=	sprintf('set%s',ucwords($attribute->getName()));
					$methods[]	=	sprintf('get%s',ucwords($attribute->getName()));

				}

				return $methods;
				
			}

			public function hasAttribute($name){

				return $this->attributeContainer->has($name);

			}

			public function getAttribute($name){

				return $this->attributeContainer->get($name);
				
			}

			public function merge(Config $config){

			}

			public function configureAttributes(){

				return $this->__configureAttributes();

			}

			abstract protected function __configureAttributes();

			/**
			 * This method returns a configuration adapter internally to be able to save, export, import
			 * a configuration object.
			 *
			 * A configuration adapter is basically a configuration format in which a Configuration object 
			 * can be exported, said formats can be: JSON, XML, INI. More formats will be supported in the future.
			 */

			private static function __getAdapter($adapter){

				$adapter			=	ucwords($adapter);
				$exportClass	=	sprintf('\\apf\\core\\config\\adapter\\%s',$adapter);

				if(!class_exists($exportClass)){

					throw new \RuntimeException("Unknown configuration adapter \"$adapter\"");

				}

				return $exportClass;

			}

			public function export($format="ini"){

				$exportClass	=	self::__getAdapter($format);

				return $exportClass::export($this->attributeContainer);

			}

			public function import($file){

				$config		=	Adapter::factory($file);

				foreach($config->parse() as $key=>$value){

					$this->$key	=	$value;

				}

			}

			public function save($format="ini"){
			}

			/************************************
			 *Iterator interface
			 ************************************/

			public function current(){

				return $this->attributeContainer->current();

			}

			public function key(){

				return $this->attributeContainer->key();

			}

			public function next(){

				return $this->attributeContainer->next();

			}

			public function rewind(){

				return $this->attributeContainer->rewind();

			}

			public function valid(){

				return $this->attributeContainer->valid();

			}

			/*************************************
			 *Magic methods
			 *************************************/

			public function __set($name,$value){

				$attribute	=	$this->attributeContainer->get($name);
				return $attribute->setValue($value);

			}

			public function __get($name){

				return $this->attributeContainer->get($name);

			}

			public function __call($method,$args){

				$isSetterOrGetter	=	strtolower(substr($method,0,3));
				$isSetter			=	$isSetterOrGetter === 'set';
				$isGetter			=	$isSetterOrGetter === 'get';

				if(!$isSetter && !$isGetter){

					throw new \BadMethodCallException("Call to undefined method: \"$method\"");

				}

				$attributeName	=	substr($method,3);

				if($isGetter){

					return $this->attributeContainer->get($attributeName)->getValue();

				}

				if($isSetter){

					return call_user_func_array(Array($this->attributeContainer->getAttribute($attributeName),'setValue'),$args);

				}

			}

			public function __toString(){

				return $this->export("ini");

			}

		}

	}
